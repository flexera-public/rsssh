#!/usr/bin/env ruby

module RSSSH
  class << self
    def command
      File.basename(__FILE__)
    end

    def slice_hash(hash, keys)
      keys.map {|x| hash[x]}.compact
    end

    def local_command_options
      [:account, :deployment, :server, :user, :command]
    end

    def title_case(string)
      string.to_s.split(/(\W)/).map {|x| x.capitalize}.join
    end

    def sample(array)
      array.respond_to?(:sample) ? array.sample : array.choice
    end

    def serialize(value)
      JSON.generate(value, :quirks_mode => true)
    end

    def deserialize(value)
      JSON.parse(value, :quirks_mode => true)
    end

    def parse_config(options)
      require 'rubygems'
      require 'json'

      config = {}

      return config unless File.exist?(options[:config_file])

      config_hosts = File.read(options[:config_file]).
        split(/^Host/).
        reject {|x| x.empty?}.
        map {|x| x.strip}

      config_hosts.each do |config_host|
        details = config_host.split(/\n/)
        host = details.shift
        config[host] = {}

        details.each do |detail|
          key, value = detail.split(' ', 2)
          config[host][key] = deserialize(value)

          config[host][key] = deserialize(config[host][key]) if key == 'LocalCommand'
        end
      end

      config
    end

    def write_config(config, options)
      File.open(options[:config_file], 'w') do |file|
        config.each do |host, config|
          file.puts("Host #{host}")

          config.each do |key, value|
            value = serialize(value) if key == 'LocalCommand'

            file.puts("  #{key} #{serialize(value)}")
          end
        end
      end
    end

    def get_client(account, options)
      begin
        require 'rubygems'
        require 'right_api_client'
      rescue LoadError
        puts "Gem 'right_api_client' is not installed in this Ruby version (#{RUBY_VERSION}). Try:"
        puts 'gem install right_api_client'
        exit
      end

      email = options[:email] || ENV['RSSSH_EMAIL']
      password = options[:password] || ENV['RSSSH_PASSWORD']

      unless email
        email = prompt('Enter your email address to connect to RightScale:')
      end

      unless password
        puts 'Enter your password to connect to RightScale:'
        print '> '

        begin
          require 'io/console'
          password = STDIN.noecho(&:gets).chomp
        rescue
          password = STDIN.gets.chomp
        end

        puts ''
      end

      RightApi::Client.new(:email => email, :password => password, :account_id => account)
    end

    def get_ip(client, deployment_name, server_name)
      instance = get_instance(client, deployment_name, server_name)

      {
        :type => instance[:type],
        :ip => sample(instance[:instance].public_ip_addresses)
      }
    end

    def get_instance(client, deployment_name, server_name)
      deployment = get_deployment(client, deployment_name)

      raise "Deployment '#{deployment}' not found" unless deployment

      server_array = deployment.server_arrays.index.find {|sa| sa.name == server_name}
      server = deployment.servers.index.find {|s| s.name == server_name}

      if server_array
        {
          :type => :server_array,
          :instance => sample(server_array.current_instances.index)
        }
      elsif server
        {
          :type => :server,
          :instance => server.current_instance.show
        }
      else
        raise "Server[Array] '#{server_name}' not found"
      end
    end

    def get_deployment(client, deployment_name)
      client.deployments.index.find {|d| d.name == deployment_name}
    end

    def prompt(string)
      puts string
      print '> '
      value = STDIN.gets.chomp
      puts ''

      value
    end

    def update_config(config, host, ip, local_command, options)
      new_config = config.merge(host => {
                                  'User' => 'rightscale',
                                  'HostName' => ip,
                                  'LocalCommand' => local_command
                                })

      unless config['*']
        new_config['*'] = {
          'PermitLocalCommand' => 'false'
        }
      end

      write_config(new_config, options)
    end

    def connect(host, options)
      config = parse_config(options)
      config_host = config[host]

      unless config_host
        puts "Host '#{host}' not found, adding."
        puts ''

        return add(host, options)
      end

      account, deployment, server, user, command = config_host['LocalCommand']

      rssh_user = user || '\$USER'
      rssh_command = "sudo su - \\\"#{rssh_user}\\\""

      if command && !command.empty?
        rssh_command += " -c \\\"#{command}\\\""
      end

      exec "ssh -t -F #{options[:config_file]} #{host} \"#{rssh_command}\""
    end

    def list(host, options)
      config = parse_config(options)
      hosts = host.nil? ? config.keys.reject {|x| x == '*'}.sort : [host]

      hosts.each do |show_host|
        config_host = config[show_host]
        local_command = config_host['LocalCommand']

        puts "Host: #{show_host}"
        puts "  IP: #{config_host['HostName']}"

        local_command_options.each_with_index do |option, i|
          puts "  #{title_case(option)}: #{local_command[i]}"
        end
      end
    end

    def add(host, options)
      config = parse_config(options)
      new_options = options.dup
      prompts = {
        :account => 'What is the account number?',
        :deployment => 'What is the deployment name?',
        :server => 'What is the server (or server array) name?',
        :user => 'Which user to switch to on login? (Blank for no change)',
        :command => 'What command to run on login? (Blank for none)'
      }

      puts "Adding host '#{host}' to #{options[:config_file]}"
      puts ''

      begin
        local_command_options.each do |key|
          new_options[key] ||= prompt(prompts[key])
        end

        local_command = slice_hash(new_options, local_command_options)
        client = get_client(local_command.first, options)
        ip = get_ip(client, local_command[1], local_command[2])[:ip]
        update_config(config, host, ip, local_command, options)

        exec "#{command} -f #{options[:config_file]} #{host}"
      rescue StandardError => e
        raise e
        puts ''
        puts "Got an error: #{e}"
        yes = prompt('Retry from the beginning? (y/n)').downcase.slice(0, 1)

        retry if yes == 'y'
      end
    end

    def update(host, options)
      config = parse_config(options)
      config_host = config[host]

      unless config_host
        puts "Host '#{host}' not found, adding."
        puts ''

        return add(host, options)
      end

      existing_options = Hash[local_command_options.zip(config_host['LocalCommand'])]
      local_command = slice_hash(existing_options.merge(options), local_command_options)
      client = get_client(local_command[0], options)
      ip = get_ip(client, local_command[1], local_command[2])[:ip]

      if ip && ip.length > 0
        update_config(config, host, ip, local_command, options)

        puts "Added new IP #{ip} for host '#{host}' to #{options[:config_file]}"
        puts ''
        exec "#{command} #{host}"
      end
    end
  end
end

if __FILE__ == $0
  require 'optparse'

  action = :connect
  options = {
    :config_file => File.expand_path(ENV['RSSSH_CONFIG_FILE'] || '~/.ssh/rsssh_config')
  }

  opt_parser = OptionParser.new do |opt|
    opt.banner = "Usage: #{RSSSH.command} HOST [OPTIONS]"

    opt.on('-c', '--connect', '[default; not required] connect to host') do
      action = :connect
    end

    opt.on('-l', '--list', 'show host details from config, or all hosts if none given') do
      action = :list
    end

    opt.on('-a', '--add', 'add a host') do
      action = :add
    end

    opt.on('-u', '--update', "update the host's IP using the RightScale API") do
      action = :update
    end

    opt.on('-f', '--config-file CONFIG_FILE', 'use alternative config file') do |config_file|
      options[:config_file] = File.expand_path(config_file)
    end

    opt.on('-h', '--help', 'show this help') do
      action = :help
    end

    opt.separator ''
    opt.separator 'When adding or updating a host:'

    opt.on('--account ACCOUNT_ID') do |account|
      options[:account] = account
    end

    opt.on('--deployment DEPLOYMENT_NAME') do |deployment|
      options[:deployment] = deployment
    end

    opt.on('--server SERVER_NAME', 'name of server or array') do |server|
      options[:server] = server
    end

    opt.on('--user USER', 'user to switch to after connect') do |user|
      options[:user] = user
    end

    opt.on('--command COMMAND', 'command to run after connect (must include a shell; try suffixing `&& /bin/bash`)') do |command|
      options[:command] = command
    end

    opt.separator ''
    opt.separator 'Credentials can be set interactively, through environment variables, or on the command line:'

    opt.on('--email EMAIL', 'email to use to connect to the RightScale API (or set RSSSH_EMAIL)') do |email|
      options[:email] = email
    end

    opt.on('--password PASSWORD', 'password to use to connect to the RightScale API (or set RSSSH_PASSWORD)') do |password|
      options[:password] = password
    end
  end

  opt_parser.parse!

  host = ARGV[0]

  if action == :help or (action == :connect and host.nil?)
    puts opt_parser
  else
    RSSSH.send(action, host, options)
  end
end
